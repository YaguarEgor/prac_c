N3: Построить грамматику для языка L1. Вставить в нее действия по генерации цепочек языка L2
    в процессе анализа методом рекурсивного спуска. Соответствие между цепочками задается
    формальным переводом тау. В качестве действий можно использовать только операторы вида cout << ′символ′.

a) L1 = { a^n c^m b^n | n>=0, m=>1 }     L2 = { 0^i 1^k | i=>0, k=>i }
   тау = { ( a^n c^m b^n, 0^n 1^(n+m) ) | n=>0, m=>1 }

    Грамматика (контекстно-свободная):
    S -> APA  
    P -> + | -  
    A -> a

Ответ:
    S -> A P A
    P -> + < cout << '+'; > | - < cout << '-'; >
    A -> a < cout << 'a'; >

b) L1 = { alpha c^n | alpha ∈ {a, b}*, n=>1}     L2 = { a^n c^m | n=>1, m=>0 }
   тау = { ( alpha c^n , a^n c^m ) | alpha ∈ {a, b}*, n=>1, m = |alpha|_a
           (т.е. m — количество символов а в цепочке alpha) }

    Грамматика (контекстно-свободная):
    S -> A | SA | SB  
    A -> a | b  
    B -> b

Ответ:
    S -> A | S A | S B
    A -> a < cout << 'a'; > | b < cout << 'b'; >
    B -> b < cout << 'b'; >


N4: Построить грамматику для языка L1. Вставить в нее действия по генерации цепочек языка L2 в процессе
    анализа методом рекурсивного спуска. Соответствие между цепочками задается формальным переводом тау.
    В качестве действий можно использовать любые операторы.

a) L1 = { 1^m 0^n | n, m>0}      L2 = { 1^k| k>0} U { 0^i| i>0} U {e},
   тау = { ( 1^m 0^n, 1^(m-n) ) | m>n>0 } U { ( 1^m 0^n, 0^(n-m) ) | n>m>0 } U { ( 1^m 0^n, e ) | m=n }

Ответ:
    S -> 1 < m = 1; n = 0; > A < while (m > n) { cout << '1'; m--; } while (n > m) { cout << '0'; n--; } >
    A -> 1 < m++; > A | 0 < n++; > B
    B -> 0 < n++; > B | e


N3: Построить грамматику для языка L1. Вставить в нее действия по генерации цепочек языка L2
    в процессе анализа методом рекурсивного спуска. Соответствие между цепочками задается
    формальным переводом тау. В качестве действий можно использовать только операторы вида cout << ′символ′.

a) L1 = { a^n c^m b^n | n>=0, m=>1 }     L2 = { 0^i 1^k | i=>0, k=>i }
   тау = { ( a^n c^m b^n, 0^n 1^(n+m) ) | n=>0, m=>1 }

    Грамматика (контекстно-свободная):
    S -> APA  
    P -> + | -  
    A -> a

Ответ:
    S -> A P A
    P -> + < cout << '+'; > | - < cout << '-'; >
    A -> a < cout << 'a'; >

b) L1 = { alpha c^n | alpha ∈ {a, b}*, n=>1}     L2 = { a^n c^m | n=>1, m=>0 }
   тау = { ( alpha c^n , a^n c^m ) | alpha ∈ {a, b}*, n=>1, m = |alpha|_a
           (т.е. m — количество символов а в цепочке alpha) }

    Грамматика (контекстно-свободная):
    S -> A | SA | SB  
    A -> a | b  
    B -> b

Ответ:
    S -> A | S A | S B
    A -> a < cout << 'a'; > | b < cout << 'b'; >
    B -> b < cout << 'b'; >

    S -> aS{'c'} | bS | B
    B -> c{'a'}C
    C -> c{'a'}C | eps


N4: Построить грамматику для языка L1. Вставить в нее действия по генерации цепочек языка L2 в процессе
    анализа методом рекурсивного спуска. Соответствие между цепочками задается формальным переводом тау.
    В качестве действий можно использовать любые операторы.

a) L1 = { 1^m 0^n | n, m>0}      L2 = { 1^k| k>0} U { 0^i| i>0} U {e},
   тау = { ( 1^m 0^n, 1^(m-n) ) | m>n>0 } U { ( 1^m 0^n, 0^(n-m) ) | n>m>0 } U { ( 1^m 0^n, e ) | m=n }

Ответ:
    S -> 1 < m = 1; n = 0; > A < while (m > n) { cout << '1'; m--; } while (n > m) { cout << '0'; n--; } >
    A -> 1 < m++; > A | 0 < n++; > B
    B -> 0 < n++; > B | e


Перевести в ПОЛИЗ следующий фрагмент программы на Си:

while (a < 10) { if (a <= b) a = b; a++; }

        1  :S
        2  a
        3  10
        4  <
        5  18 (адрес выхода из цикла)
        6  !F
        7  a
        8  b
        9  <= (проверка условия в if)
        10 13 (если a <= b false —> переход на a++)
        11 !F
        12 b
        13 a
        14 :=
        15 a
        16 @
        17 1
        18 +
        19 :=
        20 S
        21 !

Ответ: a 10 < 18 !F a b <= 13 !F b a := a @ 1 + := S !
